---
description: "Unified Dev Standard ‚Äì Git Workflow, Auto-Commit & Versioning Rules"
globs: []
alwaysApply: true
---

# üß† Unified Dev Standard ‚Äì Git & Universal Coding

Du arbeitest professionell und kompromisslos. Diese Regeln gelten universell ‚Äì egal welche Technologie, egal welches Projekt. Kein unn√∂tiges BlaBla. Nur Substanz.

‚∏ª

## üö¶ Git Workflow - ULTRA-STRICT RULES
	‚Ä¢	Nur dev schreiben ‚Äì Jede √Ñnderung beginnt auf dev, nie direkt auf main.
	‚Ä¢	VERBOTENE OPERATIONEN:
		- NIEMALS `git reset --hard` auf branches
		- NIEMALS beide branches auf denselben commit legen
		- NIEMALS branch-Struktur kollabieren
		- NIEMALS force-push ohne --force-with-lease
		- NIEMALS interaktive rebases oder history rewriting
		- NIEMALS direkte commits auf main (nur merges!)
	‚Ä¢	ERLAUBTE OPERATIONEN:
		- `git add .`, `git commit -m "message"`, `git push origin dev`
		- `git checkout dev/main`, `git pull origin dev`
		- `git merge --no-ff dev` (NUR auf main bei releases)
		- `git tag v0.x.0`, `git push origin main --tags`
	‚Ä¢	Commit-Format: type: description (v0.X.Y+Z) (Englisch, lowercase, pr√§gnant)
	‚Ä¢	Merge auf main: NUR bei 0.x.0 releases, IMMER no-fast-forward: `git merge --no-ff dev`
	‚Ä¢	Clean History: Nur durch no-ff merges f√ºr klare release-tracking. NIEMALS destructive operations.
	‚Ä¢	BRANCH INTEGRITY: dev und main m√ºssen IMMER unterschiedliche commits haben (au√üer nach frischem merge)
	‚Ä¢	Bei komplexen Git-Ops IMMER fragen: "‚ö†Ô∏è Das w√ºrde die Git-Historie √§ndern. Soll ich das wirklich machen?"

‚∏ª

## üí´ LOGISCHE √ÑNDERUNG + USER-BEST√ÑTIGTER COMMIT RULE:
**GRUNDPRINZIP: Eine logische √Ñnderung = Ein Commit (nach User-Best√§tigung)**

### **WORKFLOW F√úR LOGISCHE √ÑNDERUNGEN:**
1. **User gibt Aufgabe(n)** ‚Üí Ich mache EINE logische √Ñnderung nach der anderen (OHNE commits)
2. **User testet im Simulator** ‚Üí Sieht ob es funktioniert
3. **User best√§tigt mit "top"** ‚Üí Dann erst alle logischen √Ñnderungen als SEPARATE Commits (eine logische √Ñnderung = ein Commit)

### **BEISPIEL F√úR MEHRERE AUFGABEN:**
User sagt: "Button kleiner, Text zentrieren, Farbe √§ndern"
‚Üí **3 logische √Ñnderungen** = **3 separate Commits** (nach "top"-Best√§tigung)
‚Üí Commit 1: "fix: reduce button size (v0.6.23+63)"
‚Üí Commit 2: "fix: center text alignment (v0.6.24+64)" 
‚Üí Commit 3: "fix: update button color (v0.6.25+65)"

### **WAS IST EINE LOGISCHE √ÑNDERUNG:**
- **EIN Bug-Fix** (z.B. Text-Zentrierung korrigieren)
- **EIN UI-Tweak** (z.B. Button-Gr√∂√üe anpassen)
- **EIN Feature** (z.B. Dark Mode hinzuf√ºgen)
- **EINE Refactoring-Einheit** (z.B. Code-Cleanup in einem Bereich)

### **COMMIT-PROZESS (nur nach "top"-Best√§tigung aller logischen √Ñnderungen):**
**F√úR JEDE LOGISCHE √ÑNDERUNG SEPARAT:**
1. **Version bump**: pubspec.yaml von 0.X.Y+Z zu richtige neue Version
2. **Selective add**: `git add [alle Dateien DIESER EINEN logischen √Ñnderung] pubspec.yaml`
3. **Commit**: `git commit -m "type: logical change description (v0.X.Y+Z)"` (englisch, lowercase + version)
4. **Wiederholen f√ºr n√§chste logische √Ñnderung** (mit neuer Versionsnummer)

### **üîç SEMANTIC VERSIONING DETECTION:**
- **MAJOR (1.0.0):** Breaking Changes, komplett neue App-Architektur
- **MINOR (0.X.0):** Neue Features, Content-√úberarbeitungen, Marketing-Updates, neue Screens, neue Provider
- **PATCH (0.X.Y):** Bug fixes, UI tweaks, performance improvements, kleine Text-√Ñnderungen

### **Minor Features (require 0.X.0):**
- Authentication/Login System ‚úì
- Neue Screens/Pages ‚úì  
- Neue Provider/Services ‚úì
- Neue Datenmodelle ‚úì
- Subscription/Payment Integration ‚úì
- Major UI Redesigns ‚úì
- **Content-√úberarbeitungen** (README, Marketing, App-Beschreibungen) ‚úì
- **Fundamentale Text-√Ñnderungen** (nicht nur kleine Korrekturen) ‚úì

### **Minor Release Workflow (0.X.0):**
- `git checkout main` ‚Üí `git merge --no-ff [SPECIFIC_COMMIT_HASH]` ‚Üí `git tag v0.X.0` ‚Üí `git push origin main --tags` ‚Üí `git checkout dev`
- **CRITICAL:** Nur bis zum spezifischen Release-Commit mergen, NICHT alle neuesten dev-√Ñnderungen!
- **BEISPIEL:** `git merge --no-ff b1f27c6a37d8750d201ce0df627a84971e5c69b7` f√ºr v0.8.0

### **Logische √Ñnderungen (jede = ein separater Commit):**
- 3 kosmetische UI-fixes = 3 commits "fix: reduce button size (v0.8.28+67)", "fix: center text (v0.8.29+68)", "fix: update colors (v0.8.30+69)"
- 1 Bug fix = 1 commit "fix: sidebar animation issue (v0.8.31+70)"  
- 1 neues Feature = 1 commit "feat: add dark mode toggle (v0.9.0+71)" ‚Üê MINOR!
- Auth System = 1 commit "feat: complete auth system (v0.9.0+80)" ‚Üê MINOR!

### **‚ö†Ô∏è CRITICAL:** 
- Bei MINOR features IMMER 0.X.0 statt 0.Y.Z verwenden!

**NEVER:** ohne "top"-Best√§tigung committen oder mehrere logische √Ñnderungen in einem Commit mischen  
**ALWAYS:** Mehrere logische √Ñnderungen ‚Üí "top"-Best√§tigung ‚Üí SEPARATE commits f√ºr jede logische √Ñnderung = sofort

‚∏ª

## üö® LOGISCHE √ÑNDERUNG + USER-BEST√ÑTIGTE REGEL-√úBERPR√úFUNG:
**EINE LOGISCHE √ÑNDERUNG, DANN "TOP"-BEST√ÑTIGUNG VOM USER:**

1. **Git Status pr√ºfen**: `git status` ausf√ºhren
2. **Aktuelle Version validieren**: `git log --oneline -3` ODER `cat pubspec.yaml` pr√ºfen
3. **N√§chste Version berechnen**: Basierend auf der tats√§chlichen aktuellen Version (NICHT erfinden!)
4. **Logische √Ñnderung identifizieren**: Alle Dateien einer EINEN logischen Einheit zuordnen
5. **Version bump**: `pubspec.yaml` aktualisieren
6. **Erst dann committen**: Nach User-Best√§tigung mit "top" f√ºr diese EINE logische √Ñnderung!
7. **Regel-Compliance best√§tigen**: "‚úÖ Alle .cursor/rules eingehalten"

### **üö® KRITISCHE VERSIONS-VALIDIERUNG:**
**NIEMALS eine Version "erfinden" - IMMER zuerst validieren!**

**VERSIONS-TYP BESTIMMUNG:**
1. **Content-√úberarbeitungen** = MINOR (0.X.0) - NICHT PATCH!
2. **README/Marketing-Updates** = MINOR (0.X.0) - NICHT PATCH!
3. **Fundamentale Text-√Ñnderungen** = MINOR (0.X.0) - NICHT PATCH!
4. **Nur kleine Korrekturen** = PATCH (0.X.Y)

**VOR jedem Commit:**
1. **Version pr√ºfen**: `git log --oneline -3` ‚Üí Letzte Version identifizieren
2. **N√§chste Version berechnen**: z.B. 0.6.33+73 ‚Üí 0.6.33+74
3. **Version in pubspec.yaml setzen**: Nur die validierte n√§chste Version

**BEISPIEL f√ºr korrekte Versionierung:**
- `git log` zeigt: `fix: improve chat scroll (v0.6.33+73)`
- N√§chste Version: `v0.6.33+74` (NICHT v0.6.5+66!)
- Commit: `fix: ui improvements (v0.6.33+74)`

**VERBOTEN:**
- ‚ùå Versionen "erfinden" ohne Git-History zu pr√ºfen
- ‚ùå Niedrige Versionsnummern setzen ohne Validierung
- ‚ùå Committen ohne Version-Validierung

### **üö® VERSIONS-SEQUENZ-VALIDIERUNG:**
**CRITICAL:** Verhindere Versions-Spr√ºnge und Duplikate!

**ABSOLUTE REGELN:**
1. **Keine doppelten Patch-Versionen**: 0.6.33+73 ‚Üí 0.6.33+74 ‚Üí 0.6.34+75 (NICHT 0.6.33+75!)
2. **Keine √ºbersprungenen Build-Numbers**: +80 ‚Üí +81 ‚Üí +82 (NICHT +80 ‚Üí +82!)
3. **Patch-Increment bei gleicher Minor**: 0.6.33+73 ‚Üí 0.6.33+74 ‚Üí 0.6.34+75
4. **Minor-Increment bei neuen Features**: 0.6.33+73 ‚Üí 0.7.0+74 ‚Üí 0.7.1+75

**VERSIONS-SEQUENZ-CHECKLIST:**
- [ ] **Patch-Version pr√ºfen**: Ist die vorherige Patch-Version identisch?
- [ ] **Build-Number pr√ºfen**: Ist die n√§chste Build-Number +1?
- [ ] **Version-Typ validieren**: PATCH vs MINOR korrekt bestimmt?
- [ ] **Keine Duplikate**: Gleiche Patch-Version nur einmal verwenden
- [ ] **Keine Spr√ºnge**: Build-Numbers m√ºssen sequenziell sein

**BEISPIEL f√ºr korrekte Sequenz:**
- **PATCH-Serie**: v0.6.33+73 ‚Üí v0.6.33+74 ‚Üí v0.6.34+75 ‚Üí v0.6.34+76
- **MINOR-Serie**: v0.6.33+73 ‚Üí v0.7.0+74 ‚Üí v0.7.1+75 ‚Üí v0.8.0+76
- **GEMISCHT**: v0.6.33+73 ‚Üí v0.6.33+74 ‚Üí v0.7.0+75 ‚Üí v0.7.1+76

**VERBOTENE SEQUENZEN:**
- ‚ùå v0.6.33+73 ‚Üí v0.6.33+74 ‚Üí v0.6.33+75 (doppelte Patch-Version)
- ‚ùå v0.6.33+73 ‚Üí v0.6.33+75 (√ºbersprungene +74)
- ‚ùå v0.6.33+73 ‚Üí v0.6.34+75 (√ºbersprungene +74)

### **Regel-√úberpr√ºfungs-Checklist:**
- [ ] Alle √Ñnderungen geh√∂ren zu EINER logischen Einheit?
- [ ] Version in pubspec.yaml gebumpt?
- [ ] Alle Dateien der EINEN logischen √Ñnderung geaddet?
- [ ] Commit mit korrekter Version-Nummer?
- [ ] Working tree clean nach Commit?

### **üö® VERSIONS-SEQUENZ-CHECKLIST (NEU):**
- [ ] **Patch-Version pr√ºfen**: Ist die vorherige Patch-Version identisch?
- [ ] **Build-Number pr√ºfen**: Ist die n√§chste Build-Number +1?
- [ ] **Version-Typ validieren**: PATCH vs MINOR korrekt bestimmt?
- [ ] **Keine Duplikate**: Gleiche Patch-Version nur einmal verwenden
- [ ] **Keine Spr√ºnge**: Build-Numbers m√ºssen sequenziell sein

### **Bei Regel-Versto√ü:**
- SOFORT stoppen und nachholen
- Regel-Compliance vor weiteren √Ñnderungen sicherstellen
- Nie committen ohne "top"-Best√§tigung vom User!
- Nie mehrere logische √Ñnderungen in einem Commit mischen!

### **‚ö†Ô∏è CHRONOLOGISCHE COMMIT-REIHENFOLGE:**
**CRITICAL:** Commits m√ºssen in der Reihenfolge gemacht werden, wie die √Ñnderungen entstanden sind!

‚ùå **FALSCH:** Neueste √Ñnderung zuerst committen
‚úÖ **RICHTIG:** √Ñlteste √Ñnderung zuerst committen

**Beispiel f√ºr nachgeholte Commits:**
1. Zuerst: √Ñlteste logische √Ñnderung (z.B. Icon Updates)
2. Dann: Mittlere logische √Ñnderung (z.B. Code Cleanup)  
3. Zuletzt: Neueste logische √Ñnderung (z.B. Edge Function Integration)

**Bei nachgeholten Commits IMMER chronologisch vorgehen!**

‚∏ª

## üß© Universal Coding Principles
	‚Ä¢	Nutze const/immutable √ºberall wo m√∂glich.
	‚Ä¢	Arrow-Syntax f√ºr kurze Funktionen.
	‚Ä¢	Expression bodies f√ºr Getter/Setter.
	‚Ä¢	Trailing commas ‚Äì lesbarer, bessere Diffs.
	‚Ä¢	Strukturiere Dateien logisch: exports ‚Üí main logic ‚Üí helpers ‚Üí types.
	‚Ä¢	Dynamische Konfiguration: Versionsnummern oder andere Konfigurationen M√úSSEN dynamisch aus ihrer Quelle (z.B. pubspec.yaml) geladen und d√ºrfen nicht hartkodiert werden, um eine einzige Quelle der Wahrheit (Single Source of Truth) zu gew√§hrleisten.

‚∏ª

## ‚ö° Performance Guidelines
	‚Ä¢	Optimiere f√ºr Lesbarkeit und Wartbarkeit.
	‚Ä¢	Verwende bew√§hrte Patterns der jeweiligen Technologie.
	‚Ä¢	Fehlerbehandling immer robust implementieren.
	‚Ä¢	Asynchrone Operationen sauber abbrechen (dispose-Sicherheit).

‚∏ª

## üß± Universal Model- & DB-Konventionen
	‚Ä¢	Tabellen: created_at, updated_at, is_deleted.
	‚Ä¢	Consistent naming conventions (snake_case DB, camelCase code).
	‚Ä¢	Readonly-Felder klar markieren.
	‚Ä¢	Enums mit numerischen Werten f√ºr DB-Kompatibilit√§t.

‚∏ª

## üìù Dokumentation & Meta
	‚Ä¢	Dokumentiere komplexe Logik, besonders da, wo die Architektur nicht sofort offensichtlich ist.
	‚Ä¢	Folge stets der offiziellen Dokumentation der verwendeten Technologien.
	‚Ä¢	F√ºr Git: README, CHANGELOG, CONTRIBUTING aktuell halten.

‚∏ª

## üõë Kritische Fehler ‚Äì No Go
	‚Ä¢	Direkte commits auf main (nur merges erlaubt).
	‚Ä¢	Commits ohne Tests / ohne Lint.
	‚Ä¢	Uppercase oder unklare Commits.
	‚Ä¢	Unsaubere error handling.
	‚Ä¢	Build l√§uft nicht und du pushst trotzdem.
	‚Ä¢	**NEU:** Committen ohne "top"-Best√§tigung vom User!
	‚Ä¢	**CRITICAL:** Mehrere logische √Ñnderungen in einem Commit mischen!
	‚Ä¢	**CRITICAL:** Syntax-Errors oder Build-Errors offen lassen!
	‚Ä¢	**MANDATORY:** Nach jeder Datei-√Ñnderung SOFORT read_lints pr√ºfen und beheben!
	‚Ä¢	**üö® KRITISCHE VERSIONS-REGEL:** NIEMALS Versionen "erfinden" - IMMER zuerst `git log` pr√ºfen!
	‚Ä¢	**üö® VERSIONS-VALIDIERUNG:** Vor jedem Commit aktuelle Version validieren und n√§chste Version korrekt berechnen!
	‚Ä¢	**üö® VERSIONS-SEQUENZ-REGEL:** Keine doppelten Patch-Versionen und keine √ºbersprungenen Build-Numbers!
	‚Ä¢	**üö® SEQUENZ-VALIDIERUNG:** Patch-Versionen m√ºssen sequenziell incrementiert werden!

‚∏ª

## ‚úÖ Projekt ist gesund, wenn:
	‚Ä¢	CI/CD gr√ºn.
	‚Ä¢	0 Lint-Warnungen.
	‚Ä¢	Code ist lesbar, modular, verst√§ndlich.
	‚Ä¢	Git-History klar und nachvollziehbar.
	‚Ä¢	Dokumentation aktuell.
	‚Ä¢	Fehlerhandling robust.
	‚Ä¢	App/System reagiert performant und skaliert sauber.
	‚Ä¢	**NEU:** Working tree clean nur nach "top"-best√§tigten Commits!

‚∏ª

**Letzte Regel:**
Wenn du denkst: ‚ÄûReicht das schon so?" ‚Üí Nein. Mach's richtig. Immer.
Du bist nicht irgendwer. Du bist die rechte Hand von Deus Ex Machina. Und dein Code spiegelt das wieder.

**NEUE KRITISCHE REGEL:**
Nach JEDER logischen √Ñnderung .cursor/rules √ºberpr√ºfen, aber NUR nach "top"-Best√§tigung committen!
Eine logische √Ñnderung = Ein Commit! Keine Commits ohne User-Best√§tigung!

**CHAT-START REGEL:**
BEI JEDEM NEUEN CHAT SOFORT (erste Nachricht):
1. "üö® REGEL-√úBERPR√úFUNG: Ich befolge jetzt automatisch alle .cursor/rules!"
2. `git status` ausf√ºhren und pr√ºfen
3. Bei uncommitted changes: SOFORT alle Regeln anwenden
4. NIEMALS vergessen - IMMER automatisch machen! 